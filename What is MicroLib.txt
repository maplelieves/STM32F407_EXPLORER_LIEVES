microlib 与缺省 C 库之间的主要差异是： 
microlib 不符合 ISO C 库标准。 不支持某些 ISO 特性，并且其他特性具有的功能也较少。 
microlib 不符合 IEEE 754 二进制浮点算法标准。 
microlib 进行了高度优化以使代码变得很小。 
无法对区域设置进行配置。 缺省 C 区域设置是唯一可用的区域设置。 
不能将 main() 声明为使用参数，并且不能返回内容。 
不支持 stdio，但未缓冲的 stdin、stdout 和 stderr 除外。 
microlib 对 C99 函数提供有限的支持。 
microlib 不支持操作系统函数。 
microlib 不支持与位置无关的代码。 
microlib 不提供互斥锁来防止非线程安全的代码。 
microlib 不支持宽字符或多字节字符串。 
与 stdlib 不同，microlib 不支持可选择的单或双区内存模型。 microlib 只提供双区内存模型，即单独的堆栈和堆区。 
可以合理地将 microlib 与 --fpmode=std 或 --fpmode=fast 配合使用。 
microlib 中的函数负责： 
创建一个可在其中执行 C 程序的环境。 这包括： 
创建一个堆栈 
创建一个堆（如果需要） 
初始化程序所用的库的部分组成内容。 
调用 main() 以开始执行程序。 
要使用 microlib 构建程序，必须使用命令行选项 ??library_type=microlib。 根据需要，编译器、汇编程序或链接器可使用此选项处理不同的文件。 将此选项与链接器配合使用时，将覆盖所有其他选项。

看了原子哥的usart部分printf函数重定向的问题，自己动手试了试，单片机可以通过串口打印信息，printf函数重定向后使用十分方便。
所谓重定向是指修改printf的底层函数，使printf打印到单片机的外设中。还有一个概念是半主机。
半主机是用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机。 例如，使用此机制可以启用 C 库中的函数，如 printf() 和 scanf()，来使用主机的屏幕和键盘，而不是在目标系统上配备屏幕和键盘。这种机制很有用，因为开发时使用的硬件通常没有最终系统的所有输入和输出设备。 半主机可让主机来提供这些设备。半主机是通过一组定义好的软件指令（如 SVC）来实现的，这些指令通过程序控制生成异常。 应用程序调用相应的半主机调用，然后调试代理处理该异常。 调试代理提供与主机之间的必需通信。半主机接口对 ARM 公司提供的所有调试代理都是通用的。 在无需移植的情况下使用 RealView ARMulator® ISS、指令集系统模型 (ISSM)、实时系统模型 (RTSM)、RealView ICE 或 RealMonitor 时，会执行半主机操作。标准库使用半主机模式，半主机是通过一组定义好的软件指令 （如 SVC）SVC 指令 （以前称为 SWI 指令）来实现的，这些指令通过程序控制生成异常。 应用程序调用相应的半主机调用，然后调试代理处理该异常。调试代理（这里的调试代理是仿真器）提供与主机之间的必需通信。也就是说使用半主机模式必须使用仿真器调试。ARMv7 之前的 ARM 处理器使用 SVC 指令 （以前称为 SWI 指令）进行半主机调用。 但是，如果要为 ARMv6-M 或 ARMv7-M （如 Cortex™-M1 或 Cortex-M3 处理器）进行编译，请使用 BKPT 指令来实现半主机。简单的来说，半主机模式就是通过仿真器实现开发板在电脑上的输入和输出。和半主机模式功能相同的是ITM调试机制。
上面介绍的半主机和ITM功能相当，他们都是调试机制，开发板均借助仿真器与电脑连接，实现单片机利用主机的屏幕键盘的输入输出。这两种机制的运行均需要仿真器，否则无法运行。
开发式一般单片机需要独立运行，开发者应去掉仿真器，把printf函数通过单片机的外设来实现，例如通过开发板的串口，lcd或者sd卡。      
MDK中通常使用以下两种方法：
方法1.使用微库,因为使用微库的话,不会使用半主机模式. 
int fputc(int ch, FILE *f){
  while((USART1->SR&0X40)==0);
  USART1->DR = (u8) ch;
  return ch; }
方法2.仍然使用标准库,在主程序添加下面代码:
#pragma import(__use_no_semihosting)
struct __FILE  {  int handle;  };
FILE __stdout;
_sys_exit(int x){
  x = x;
}
int fputc(int ch, FILE *f) {
  while((USART1->SR&0X40)==0);
  USART1->DR = (u8) ch;
  return ch;
}
关于 microlibmicrolib 是缺省 C 库的备选库。 它用于必须在极少量内存环境下运行的深层嵌入式应用程序。 这些应用程序不在操作系统中运行。microlib 不会尝试成为符合标准的 ISO C 库。microlib 进行了高度优化以使代码变得很小。 它的功能比缺省 C 库少，并且根本不具备某些 ISO C 特性。某些库函数的运行速度也比较慢，例如，memcpy()。上面给出了正确的方法，我在测试的过程中发现方法二中注释掉#pragma import(__use_no_semihosting) 程序依然运行正确，这个很让人费解。也有使用#pragma import(__use_no_semihosting_swi)的。这几个的区别我没弄懂。如果使用微库或者禁用半主机，没有重定义fputc函数，程序可以运行，但不知道结果打印到主机的哪个地方去了。既没有禁用半主机也没有重定义fputc函数，程序将一直停在中断处. 网上的大部分资料都是禁用了半主机模式，没有使用过半主机模式借助主机的键盘输入参数，看了很多资料，都是讲半主机的，但讲的内容太浅显，我没有学会使用半主机，更多的是学会了禁用半主机模式，我们好像忽略了半主机模式的意义。另外，我们可以查到的大部分资料讲解的大同小异，它们更多的告诉我们正确的步骤，而不是让我们从源头了解一个问题，当然，大部分人看重的是实用，问题解决了，也就不再去思考背后的原理。最有效最直接最权威的资料是mdk官方给出的资料，但是资料内容太多，看起来太多，不易懂，大部分人没有看下去的欲望。我们应该让使用手册看起来更直观，更易懂，更方便查阅，更高效地查阅。第一个给出此类问题的解决方法的人，他们以通俗易懂的方式告诉了广大开发者，他们阅读了这些晦涩的手册，他们是真的勇士！
